TinyBase – Final Project Specification

1. Overview

TinyBase is a lightweight, self-hosted BaaS framework for Python developers, conceptually similar to PocketBase but:
	•	Implemented in Python.
	•	Uses SQLite as the primary database.
	•	Provides:
	•	Auth (users, tokens, permissions).
	•	Collections + Records (generic data with validation).
	•	Typed server-side functions (“actions”) with:
	•	Pydantic input/output models.
	•	A structured Context object.
	•	CLI-based deployment.
	•	Scheduling (once, interval, cron).
	•	Execution metadata (FunctionCall).
	•	Web-based admin UI SPA (Vue3 + Pinia + Vite + PicoCSS).
	•	OpenAPI-based API documentation.

Distribution:
	•	pip install tinybase → tinybase serve.
	•	Docker image → docker run tinybase.
	•	Development and dependency management via uv (Astral).

Design goals:
	•	Minimal, understandable codebase.
	•	Small but pragmatic dependency set.
	•	No built-in job abstraction (users model jobs via collections + functions, Supabase-style).

⸻

2. Tech Stack & Dependencies

2.1 Backend core
	•	FastAPI – HTTP framework, routing, OpenAPI.
	•	Uvicorn – ASGI server.
	•	SQLModel – ORM/data models on top of SQLAlchemy.
	•	SQLite – default DB.
	•	Pydantic v2 – validation and settings.

2.2 Auth & security
	•	passlib[bcrypt] – password hashing.
	•	Opaque token model (AuthToken) stored in DB, used as Bearer tokens.

2.3 Scheduling
	•	croniter – cron expression parsing and next-run computation.

2.4 CLI & tooling
	•	typer – CLI implementation.
	•	Optional: python-dotenv – environment loading.

2.5 Project & dependency management
	•	uv as primary dev tool:
	•	uv init tinybase
	•	uv add fastapi sqlmodel pydantic passlib[bcrypt] croniter uvicorn[standard] typer
	•	uv run tinybase/cli.py serve
	•	Published to PyPI (standard pyproject.toml).

2.6 Admin UI
	•	Vue 3 – SPA framework (Composition API).
	•	Pinia – state management.
	•	Vite – build tool.
	•	PicoCSS – minimal CSS framework for styling.

Admin UI source lives in /app, built with Vite to /app/dist and then included into the Python package (e.g. copied to tinybase/admin_static at build time).

⸻

3. Package Layout

High-level structure:

project-root/
  app/                      # Vue3 + Pinia + Vite + PicoCSS admin UI source
    src/
    index.html
    vite.config.ts
    package.json
    ...
    dist/                   # Vite build output (compiled SPA)

  tinybase/
    __init__.py
    config.py               # settings loader (env + tinybase.toml)
    cli.py                  # tinybase CLI (init, serve, functions new/deploy)
    version.py

    db/
      __init__.py
      core.py               # DB engine / session helpers
      models.py             # SQLModel models (User, AuthToken, Collection, Record, FunctionCall, FunctionSchedule)

    collections/
      __init__.py
      schemas.py            # collection schema JSON + Pydantic builders + registry
      service.py            # business logic for collections & records

    functions/
      __init__.py           # exports Context, public interface
      context.py            # Pydantic Context model
      core.py               # function registry, metadata, execution helpers
      register.py           # @register decorator

    api/
      __init__.py
      app.py                # FastAPI app factory + startup hooks
      routes/
        __init__.py
        auth.py             # /api/auth/*
        collections.py      # /api/collections/* and record CRUD
        functions.py        # /api/functions/* + listing
        admin.py            # /api/admin/functions, /api/admin/functions/calls
        schedules.py        # /api/admin/schedules/*
        static_admin.py     # /admin static mount

    admin_static/           # built SPA assets copied from app/dist at build time

  tinybase.toml             # optional default config for local dev
  pyproject.toml
  Dockerfile
  README.md
  LICENSE
  tests/
    ...


⸻

4. Core Data Models (SQLModel)

All DB models live in tinybase/db/models.py.

4.1 User

class User(SQLModel, table=True):
    id: UUID = Field(primary_key=True, default_factory=uuid4)
    email: str = Field(index=True, unique=True)
    password_hash: str
    is_admin: bool = False
    created_at: datetime = Field(default_factory=datetime.utcnow)
    updated_at: datetime = Field(default_factory=datetime.utcnow)

4.2 AuthToken (opaque tokens)

class AuthToken(SQLModel, table=True):
    id: UUID = Field(primary_key=True, default_factory=uuid4)
    user_id: UUID = Field(foreign_key="user.id")
    token: str = Field(index=True, unique=True)
    created_at: datetime = Field(default_factory=datetime.utcnow)
    expires_at: datetime | None = None

4.3 Collection

class Collection(SQLModel, table=True):
    id: UUID = Field(primary_key=True, default_factory=uuid4)
    name: str = Field(index=True, unique=True)
    label: str
    schema: dict                         # TinyBase collection schema JSON
    options: dict = Field(default_factory=dict)  # access rules etc.
    created_at: datetime = Field(default_factory=datetime.utcnow)
    updated_at: datetime = Field(default_factory=datetime.utcnow)

4.4 Record

class Record(SQLModel, table=True):
    id: UUID = Field(primary_key=True, default_factory=uuid4)
    collection_id: UUID = Field(foreign_key="collection.id", index=True)
    owner_id: UUID | None = Field(default=None, foreign_key="user.id")
    data: dict                           # JSON payload validated by Pydantic
    created_at: datetime = Field(default_factory=datetime.utcnow)
    updated_at: datetime = Field(default_factory=datetime.utcnow)

4.5 FunctionCall (metadata only)

class FunctionCall(SQLModel, table=True):
    id: UUID = Field(primary_key=True, default_factory=uuid4)

    function_name: str

    status: Literal["running", "succeeded", "failed"]

    trigger_type: Literal["manual", "schedule"]
    trigger_id: UUID | None = None

    requested_by_user_id: UUID | None = None

    started_at: datetime | None = None
    finished_at: datetime | None = None
    duration_ms: int | None = None

    error_message: str | None = None
    error_type: str | None = None

    created_at: datetime = Field(default_factory=datetime.utcnow)

No payloads or results are stored.

4.6 FunctionSchedule (single schedule JSON field)

class FunctionSchedule(SQLModel, table=True):
    id: UUID = Field(primary_key=True, default_factory=uuid4)

    name: str
    function_name: str

    schedule: dict                        # JSON; validated via Pydantic schedule models

    is_active: bool = True

    last_run_at: datetime | None = None
    next_run_at: datetime | None = None

    created_by_user_id: UUID | None = None
    created_at: datetime = Field(default_factory=datetime.utcnow)
    updated_at: datetime = Field(default_factory=datetime.utcnow)


⸻

5. DB Core

In tinybase/db/core.py:
	•	Create engine from config (SQLite by default).
	•	Provide functions for getting sessions (sync or async).
	•	Provide create_db_and_tables() to initialize all tables.

⸻

6. Collection Schemas & Dynamic Models

Located in tinybase/collections/schemas.py and tinybase/collections/service.py.

6.1 Schema JSON format (stored in Collection.schema)

Example:

{
  "fields": [
    {
      "name": "title",
      "type": "string",
      "required": true,
      "max_length": 200
    },
    {
      "name": "published",
      "type": "boolean",
      "required": false,
      "default": false
    },
    {
      "name": "tags",
      "type": "list[string]",
      "required": false,
      "default": []
    },
    {
      "name": "rating",
      "type": "int",
      "required": false,
      "min": 0,
      "max": 5
    }
  ]
}

Supported types and constraints as previously described.

6.2 Dynamic Pydantic models

At startup, TinyBase:
	•	Loads Collection rows from DB.
	•	For each, builds a Pydantic model with field constraints.
	•	Registers models in CollectionModelRegistry (in schemas.py).

service.py:
	•	Uses these models to:
	•	validate incoming record data.
	•	perform CRUD operations on Record table.
	•	Provides CRUD helpers used by api/routes/collections.py.

Schema changes:
	•	MVP: require app restart for new schema to affect validation and OpenAPI.

⸻

7. Auth API

Located in tinybase/api/routes/auth.py.

Base path: /api/auth

Endpoints:
	•	POST /api/auth/register
	•	POST /api/auth/login
	•	GET /api/auth/me

Uses:
	•	User and AuthToken models.
	•	passlib[bcrypt] for password hashing.
	•	Dependencies provided in auth helper module (could be in tinybase/auth.py or a submodule of db/api as appropriate).

⸻

8. Collections API

Located in tinybase/api/routes/collections.py.

Base path: /api/collections

8.1 Collections
	•	GET /api/collections
	•	POST /api/collections (admin-only)
	•	GET /api/collections/{collection_name}

8.2 Records

Base: /api/collections/{collection_name}/records
	•	GET /api/collections/{collection_name}/records
	•	Pagination + simple filtering.
	•	POST /api/collections/{collection_name}/records
	•	GET /api/collections/{collection_name}/records/{id}
	•	PATCH /api/collections/{collection_name}/records/{id}
	•	DELETE /api/collections/{collection_name}/records/{id}

Routes use collection-specific Pydantic models from CollectionModelRegistry.

⸻

9. Functions Subsystem

All function-related components live under tinybase/functions.

9.1 Context model

tinybase/functions/context.py defines Context:

from pydantic import BaseModel, ConfigDict
from typing import Literal
from uuid import UUID
from datetime import datetime
from fastapi import Request
from sqlalchemy.orm import Session  # or SQLModel session type

class Context(BaseModel):
    model_config = ConfigDict(arbitrary_types_allowed=True)

    function_name: str
    trigger_type: Literal["manual", "schedule"]
    trigger_id: UUID | None = None
    request_id: UUID

    user_id: UUID | None = None
    is_admin: bool = False

    now: datetime

    db: Session
    request: Request | None = None

tinybase/functions/__init__.py exports:

from .context import Context

9.2 Function registry & metadata

tinybase/functions/core.py:
	•	Holds FunctionRegistry class:
	•	Maps function names to metadata and callables.
	•	Provides all(), get(name), register(...).
	•	Defines metadata structure:

class FunctionMeta(BaseModel):
    name: str
    description: str | None
    auth: Literal["public", "auth", "admin"]
    tags: list[str]
    input_model: type[BaseModel] | None
    output_model: type[BaseModel] | None
    module: str
    file_path: str
    last_loaded_at: datetime


	•	Provides helpers for:
	•	executing functions with a Context.
	•	recording FunctionCall metadata.

9.3 Decorator: register

tinybase/functions/register.py:
	•	Exports a register decorator for users:

from typing import Callable, Literal
from pydantic import BaseModel
from .core import get_global_registry  # or similar

def register(
    name: str,
    description: str | None = None,
    auth: Literal["public", "auth", "admin"] = "auth",
    input_model: type[BaseModel] | None = None,
    output_model: type[BaseModel] | None = None,
    tags: list[str] | None = None,
):
    def decorator(func: Callable):
        # introspect module/file_path, register into global FunctionRegistry
        ...
        return func
    return decorator

Usage in functions.py:

from pydantic import BaseModel
from tinybase.functions.register import register
from tinybase.functions import Context

class AddInput(BaseModel):
    x: int
    y: int

class AddOutput(BaseModel):
    sum: int

@register(
    name="add_numbers",
    description="Add two numbers",
    auth="auth",
    input_model=AddInput,
    output_model=AddOutput,
    tags=["math"],
)
def add_numbers(ctx: Context, payload: AddInput) -> AddOutput:
    return AddOutput(sum=payload.x + payload.y)


⸻

10. Functions HTTP Layer

Implemented in tinybase/api/routes/functions.py.

At app startup:
	•	Import and load user function modules from functions path.
	•	Registry is populated via @register decorator.
	•	Build FastAPI routes from registry:
	•	POST /api/functions/{name} with response_model bound to output_model.
	•	Uses input_model for request body.

Handler factory:
	•	For each FunctionMeta:
	•	Create a handler that:
	•	performs auth (using meta.auth).
	•	builds Context.
	•	creates a FunctionCall row (status="running").
	•	calls the underlying Python function.
	•	updates FunctionCall (status, duration, errors).
	•	returns function result as HTTP response.

10.1 Listing functions

Endpoints:
	•	GET /api/functions
	•	Returns list of FunctionInfo:

class FunctionInfo(BaseModel):
    name: str
    description: str | None = None
    auth: Literal["public", "auth", "admin"]
    tags: list[str] = []

Filtered by caller’s auth level.

	•	GET /api/admin/functions (admin only)
	•	Returns AdminFunctionInfo:

class AdminFunctionInfo(FunctionInfo):
    module: str
    file_path: str
    last_loaded_at: datetime



10.2 Function calls metadata endpoints

In tinybase/api/routes/admin.py:
	•	GET /api/admin/functions/calls
	•	Query params: function_name, status, trigger_type, time range, pagination.
	•	GET /api/admin/functions/calls/{id}
	•	Returns one FunctionCall.

⸻

11. Scheduling

11.1 Schedule models (Pydantic)

In tinybase/api/routes/schedules.py or a dedicated tinybase/scheduling.py helper, define schedule configs:

from datetime import datetime, date, time, timedelta
from typing import Literal, Union, Annotated
from pydantic import BaseModel, Field, ConfigDict
from croniter import croniter
import zoneinfo

Base:

class BaseScheduleConfig(BaseModel):
    model_config = ConfigDict(extra="forbid")

    method: Literal["once", "interval", "cron"]
    timezone: str = "UTC"

    def tzinfo(self):
        return zoneinfo.ZoneInfo(self.timezone)

    def next_run_after(self, from_time: datetime) -> datetime:
        raise NotImplementedError

Once:

class OnceScheduleConfig(BaseScheduleConfig):
    method: Literal["once"] = "once"
    date: date
    time: time

    def next_run_after(self, from_time: datetime) -> datetime:
        tz = self.tzinfo()
        target = datetime.combine(self.date, self.time, tzinfo=tz)
        return target

Interval:

class IntervalScheduleConfig(BaseScheduleConfig):
    method: Literal["interval"] = "interval"
    unit: Literal["seconds", "minutes", "hours", "days"]
    value: int = Field(gt=0)

    def next_run_after(self, from_time: datetime) -> datetime:
        tz = self.tzinfo()
        base = from_time.astimezone(tz)
        delta_map = {
            "seconds": timedelta(seconds=self.value),
            "minutes": timedelta(minutes=self.value),
            "hours": timedelta(hours=self.value),
            "days": timedelta(days=self.value),
        }
        return base + delta_map[self.unit]

Cron:

class CronScheduleConfig(BaseScheduleConfig):
    method: Literal["cron"] = "cron"
    cron: str
    description: str | None = None

    def next_run_after(self, from_time: datetime) -> datetime:
        tz = self.tzinfo()
        base = from_time.astimezone(tz)
        it = croniter(self.cron, base)
        return it.get_next(datetime).astimezone(tz)

Discriminated union:

ScheduleConfig = Annotated[
    Union[OnceScheduleConfig, IntervalScheduleConfig, CronScheduleConfig],
    Field(discriminator="method"),
]

Helper to parse:

def get_schedule_config(fs: FunctionSchedule) -> ScheduleConfig:
    return ScheduleConfig.model_validate(fs.schedule)

11.2 Scheduler loop

In tinybase/api/app.py or a dedicated scheduler helper:
	•	On startup:

@app.on_event("startup")
async def startup():
    create_db_and_tables()
    # other inits
    start_scheduler()

	•	Scheduler (background task):

async def scheduler_loop():
    interval = settings.scheduler_interval_seconds  # e.g. 5
    while True:
        now = utcnow()
        with Session(engine) as session:
            due = (
                session.exec(
                    select(FunctionSchedule)
                    .where(
                        FunctionSchedule.is_active == True,
                        FunctionSchedule.next_run_at <= now,
                    )
                ).all()
            )
            for fs in due:
                cfg = get_schedule_config(fs)
                # create FunctionCall, run function via registry/core helper
                run_scheduled_function(fs.function_name, cfg, fs, session, now)
        await asyncio.sleep(interval)

run_scheduled_function:
	•	Builds Context (trigger_type="schedule", trigger_id=fs.id).
	•	Uses function registry to call underlying function.
	•	Writes FunctionCall metadata.
	•	Updates fs.last_run_at.
	•	Computes fs.next_run_at using cfg.next_run_after(now):
	•	For OnceScheduleConfig, after first run set fs.is_active=False and fs.next_run_at=None.

11.3 Schedule endpoints (admin)

In tinybase/api/routes/schedules.py:
	•	GET /api/admin/schedules
	•	POST /api/admin/schedules
	•	Body includes name, function_name, and a schedule object using ScheduleConfig.
	•	GET /api/admin/schedules/{id}
	•	PATCH /api/admin/schedules/{id}
	•	DELETE /api/admin/schedules/{id}

No built-in job abstraction; jobs are modeled by users in their own collections and functions.

⸻

12. Admin UI SPA

Source in /app (project root):
	•	Vue 3 + Pinia + Vite + PicoCSS.
	•	Features:
	•	Admin login (via /api/auth/login).
	•	Collections overview and editor.
	•	Record list/detail views.
	•	User overview.
	•	Functions overview (from /api/admin/functions).
	•	Schedule overview and editor.
	•	Function calls history view.

Build:
	•	Use Vite to build to /app/dist.
	•	As part of the package build/publish step:
	•	Copy /app/dist into tinybase/admin_static.
	•	FastAPI serves SPA from tinybase/admin_static:
In tinybase/api/routes/static_admin.py:

from fastapi.staticfiles import StaticFiles

def mount_admin_ui(app: FastAPI, static_dir: str):
    app.mount("/admin", StaticFiles(directory=static_dir, html=True), name="admin")

Called in api/app.py with static_dir pointing to tinybase/admin_static.

⸻

13. CLI & Configuration

13.1 Configuration sources & philosophy

Goals:
	•	Simple, “typical” config knobs.
	•	Not overengineered.
	•	Admins can quickly adjust basics via env vars or tinybase.toml.

Precedence:
	1.	Environment variables (for deployment).
	2.	tinybase.toml in current directory.
	3.	Hard-coded defaults.

Use a Pydantic settings class in tinybase/config.py (e.g. Settings).

13.2 Typical configuration parameters / env vars

Examples (not exhaustive, but practical and minimal):

Server:
	•	TINYBASE_SERVER_HOST (default: "0.0.0.0")
	•	TINYBASE_SERVER_PORT (default: 8000)
	•	TINYBASE_DEBUG (default: false)
	•	TINYBASE_LOG_LEVEL (default: "info")

Database:
	•	TINYBASE_DB_URL (default: sqlite:///./tinybase.db)

Auth:
	•	TINYBASE_AUTH_TOKEN_TTL_HOURS (default: 24)

Functions:
	•	TINYBASE_FUNCTIONS_PATH (default: ./functions)
	•	TINYBASE_FUNCTIONS_FILE (default: ./functions.py)

Scheduler:
	•	TINYBASE_SCHEDULER_ENABLED (default: true)
	•	TINYBASE_SCHEDULER_INTERVAL_SECONDS (default: 5)

CORS (simple but useful):
	•	TINYBASE_CORS_ALLOW_ORIGINS (default: * or empty → no CORS)

Admin bootstrap (used by tinybase init if envs present):
	•	TINYBASE_ADMIN_EMAIL
	•	TINYBASE_ADMIN_PASSWORD

Admin UI:
	•	Usually no config needed beyond base path, but optionally:
	•	TINYBASE_ADMIN_STATIC_DIR (defaults to built-in tinybase/admin_static).

Each of these also appears in tinybase.toml under similar sections, e.g.:

[server]
host = "0.0.0.0"
port = 8000
debug = false
log_level = "info"

[database]
url = "sqlite:///./tinybase.db"

[auth]
token_ttl_hours = 24

[functions]
path = "./functions"
file = "./functions.py"

[scheduler]
enabled = true
interval_seconds = 5

[cors]
allow_origins = ["*"]

[admin]
static_dir = "builtin"   # or "./custom-admin"

13.3 CLI commands

tinybase CLI implemented via typer in tinybase/cli.py.

Commands:
	1.	tinybase init
	•	Create tinybase.toml if missing.
	•	Create functions.py with example function if missing.
	•	Initialize DB (create_db_and_tables()).
	•	Optionally create admin user:
	•	If TINYBASE_ADMIN_EMAIL & TINYBASE_ADMIN_PASSWORD set, use them.
	•	Otherwise, prompt interactively (optional).
	2.	tinybase serve
	•	Reads Settings.
	•	Starts Uvicorn: uvicorn tinybase.api.app:create_app --factory --host HOST --port PORT.
	3.	tinybase functions deploy --env ENV
	•	Uses [environments.ENV] in tinybase.toml:
	•	url
	•	api_token
	•	Creates an archive of function code (e.g. functions.py and functions/).
	•	Sends POST {url}/api/admin/functions/deploy with Bearer token.
	•	Server extracts, reloads functions.
	4.	tinybase functions new <function_name> -d <description>
	•	Ensures functions.py exists.
	•	Appends boilerplate for a new function, e.g.:

from pydantic import BaseModel
from tinybase.functions.register import register
from tinybase.functions import Context


class <CamelCaseName>Input(BaseModel):
    # TODO: define fields
    pass


class <CamelCaseName>Output(BaseModel):
    # TODO: define fields
    pass


@register(
    name="<function_name>",
    description="<description>",
    auth="auth",
    input_model=<CamelCaseName>Input,
    output_model=<CamelCaseName>Output,
    tags=[],
)
def <function_name>(ctx: Context, payload: <CamelCaseName>Input) -> <CamelCaseName>Output:
    # TODO: implement logic
    return <CamelCaseName>Output()


	•	<CamelCaseName> derived from <function_name>.

⸻

14. OpenAPI & Client Generation
	•	FastAPI auto-exposes /openapi.json.
	•	Collections:
	•	Each collection’s dynamic Pydantic models appear as named schemas in OpenAPI.
	•	Functions:
	•	/api/functions/{name} endpoints use declared input_model and output_model.
	•	Schedules and admin endpoints also appear.

Clients:
	•	Users can run openapi-generator or similar tools to generate:
	•	TypeScript clients.
	•	Python clients.

⸻

15. Implementation Phases (High-Level)
	1.	Foundation
	•	Project structure with uv.
	•	Settings in config.py.
	•	db/core.py and db/models.py.
	•	Minimal FastAPI app (api/app.py) and tinybase serve.
	2.	Auth
	•	Implement User + AuthToken logic.
	•	api/routes/auth.py endpoints.
	3.	Collections
	•	JSON schema format + dynamic Pydantic models (collections/schemas.py).
	•	CRUD logic (collections/service.py).
	•	api/routes/collections.py with dynamic routes.
	4.	Functions Core
	•	Context model.
	•	FunctionRegistry + metadata (functions/core.py).
	•	register decorator (functions/register.py).
	•	FunctionCall model and logging.
	5.	Function HTTP Layer
	•	api/routes/functions.py:
	•	POST /api/functions/{name}.
	•	Listing endpoints.
	•	Admin function call listing in api/routes/admin.py.
	6.	Scheduling
	•	FunctionSchedule model.
	•	Pydantic schedule configs.
	•	Scheduler loop.
	•	api/routes/schedules.py.
	7.	Functions Deployment & CLI
	•	CLI tinybase functions deploy.
	•	Server endpoint /api/admin/functions/deploy.
	•	CLI tinybase functions new.
	8.	Admin UI
	•	Vue3 + Pinia + Vite + PicoCSS in /app.
	•	Build to /app/dist and copy into tinybase/admin_static.
	•	Serve via /admin.
	9.	Packaging & Docker
	•	PyPI packaging.
	•	Dockerfile with CMD ["tinybase", "serve", ...].
	•	Basic documentation and examples.
